## 2. Tipe Data


### Kontrol Presisi dan Memori

Tidak seperti Python standar yang hanya memiliki tipe int dan float yang umum, NumPy menyediakan berbagai tipe data numerik dengan presisi yang berbeda-beda. Ini termasuk int8, int16, int32, int64 untuk integer, float16, float32, float64 untuk bilangan floating-point, dan complex64, complex128 untuk bilangan kompleks.
Kemampuan untuk memilih tipe data secara spesifik adalah fitur desain yang strategis dalam komputasi ilmiah. Pemilihan dtype adalah sebuah trade-off antara presisi numerik dan penggunaan sumber daya. Misalnya, menggunakan float32 alih-alih float64 (default) akan mengurangi separuh penggunaan memori dan *bandwidth* I/O. Ini sangat signifikan untuk dataset yang sangat besar atau saat melakukan komputasi pada GPU yang memiliki memori terbatas, meskipun dengan risiko kehilangan presisi pada perhitungan yang sensitif.

### Menentukan dan Mengubah Tipe Data

Kita dapat secara eksplisit menentukan tipe data saat membuat array menggunakan argumen dtype. Jika tidak ditentukan, NumPy akan mencoba menebak tipe data yang paling sesuai dari data input.

Python


```python
# Membuat array dengan tipe data yang ditentukan
arr_int = np.array(, dtype=np.int32)
arr_float = np.array(, dtype=np.float64)
arr_complex = np.array(, dtype=np.complex128)

print(f"Array Integer: {arr_int}, dtype: {arr_int.dtype}")
print(f"Array Float: {arr_float}, dtype: {arr_float.dtype}")
print(f"Array Complex: {arr_complex}, dtype: {arr_complex.dtype}")
```
**Output:**



Array Integer: [1 2 3], dtype: int32
Array Float: [1. 2. 3.], dtype: float64
Array Complex: [1.+0.j 2.+0.j 3.+0.j], dtype: complex128
Untuk mengubah tipe data dari array yang sudah ada, kita harus membuat salinan baru menggunakan metode astype(). Metode ini tidak mengubah array asli.

Python


```python
data_float = np.array([1.1, 2.7, 3.5], dtype=np.float64)
print(f"Array Asli: {data_float}, dtype: {data_float.dtype}")

# Typecasting ke integer (bagian desimal akan dipotong/truncated)
data_int = data_float.astype(np.int64)
print(f"Array Hasil Cast: {data_int}, dtype: {data_int.dtype}")
```
**Output:**



Array Asli: [1.1 2.7 3.5], dtype: float64
Array Hasil Cast: [1 2 3], dtype: int64

### Promosi Tipe (Type Promotion)

Ketika operasi aritmatika dilakukan antara array dengan dtype yang berbeda, NumPy secara otomatis akan "mempromosikan" hasilnya ke tipe data yang lebih umum atau presisi untuk mencegah kehilangan informasi.
int32 + int64 → int64
int64 + float32 → float64
float64 + complex64 → complex128

Python


```python
d1 = np.array(, dtype=np.int32)
d2 = np.array([1.0, 2.0, 3.0], dtype=np.float32)
hasil = d1 + d2

print(f"Hasil: {hasil}, dtype: {hasil.dtype}") # Hasilnya akan menjadi float64
```
**Output:**



Hasil: [2. 3. 4.], dtype: float64

### Contoh Kasus Kritis: Pentingnya Tipe Data

Pemilihan dtype yang salah dapat menyebabkan hasil yang salah secara matematis. Contoh klasik adalah menghitung akar kuadrat dari bilangan negatif.

Python


```python
# Dengan dtype default (float), akar dari -1 menghasilkan NaN (Not a Number)
arr_real = np.array([-1, 0, 1], dtype=np.float64)
print(f"Akar dengan dtype float: {np.sqrt(arr_real)}")

# Dengan dtype complex, hasilnya benar secara matematis
arr_complex = np.array([-1, 0, 1], dtype=np.complex128)
print(f"Akar dengan dtype complex: {np.sqrt(arr_complex)}")
```
**Output:**



Akar dengan dtype float: [nan  0.  1.]
Akar dengan dtype complex: [0.+1.j 0.+0.j 1.+0.j]
Contoh ini menggarisbawahi bahwa pemahaman dtype sangat penting untuk memastikan kebenaran hasil komputasi.
