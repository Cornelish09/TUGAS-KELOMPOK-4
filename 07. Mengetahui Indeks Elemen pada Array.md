## 7. Mengetahui Indeks Elemen pada Array

Mengakses dan memanipulasi sebagian data dari array adalah operasi fundamental. NumPy menawarkan sistem pengindeksan yang kaya dan kuat.

### Pengindeksan Dasar dan Slicing

Untuk array 1D, sintaksnya identik dengan list Python: a[index] untuk satu elemen dan a[start:stop:step] untuk *slicing* (membuat irisan). Indeks negatif dihitung dari akhir.
Untuk array multidimensi, kita menggunakan *tuple* indeks yang dipisahkan koma: A[baris, kolom]. Kita dapat menggabungkan indeks integer dan *slice* untuk mengekstrak baris, kolom, atau sub-matriks.

Python


```python
A = np.arange(1, 10).reshape(3, 3)
# A = [,
#      ,
#      ]

# Elemen di baris 1, kolom 2 (indeks 0-based)
print(A) # Output: 6

# Baris pertama (indeks 0)
print(A[0, :]) # Output: [1 2 3]

# Kolom kedua (indeks 1)
print(A[:, 1]) # Output: [2 5 8]

# Sub-matriks 2x2 di pojok kanan atas
print(A[:2, 1:])
# Output:
# [[2 3]
#  [5 6]]

```
### Konsep Kritis: Views vs. Copies

Saat melakukan *slicing* dasar, NumPy tidak membuat salinan data. Sebaliknya, ia membuat sebuah view, yaitu objek ndarray baru yang menunjuk ke data yang sama di memori dengan array asli.
Implikasi: Mengubah nilai dalam *view* akan mengubah array asli. Ini adalah fitur optimisasi yang kuat karena menghindari penyalinan data yang mahal, tetapi bisa menjadi sumber bug yang sulit dilacak jika tidak disadari.

Python


```python
A = np.array()
B_view = A[1:4] # B_view adalah view dari A
print(f"B_view sebelum diubah: {B_view}") # Output: [20 30 40]

B_view = 99 # Mengubah elemen di view
print(f"B_view setelah diubah: {B_view}") # Output: [20 99 40]
print(f"Array A asli juga berubah: {A}") # Output: [10 20 99 40 50]

# Untuk membuat salinan, gunakan.copy()
C_copy = A[1:4].copy()
C_copy = 0
print(f"Array A tidak berubah oleh C_copy: {A}") # Output: [10 20 99 40 50]

```
### Pengindeksan Lanjutan (Fancy & Boolean)

Berbeda dengan *slicing* dasar, pengindeksan lanjutan ini selalu membuat salinan data.
**Fancy Indexing**: Menggunakan list atau array integer untuk memilih elemen-elemen pada indeks tertentu, bahkan jika tidak berurutan.
**Boolean Indexing**: Menggunakan array Boolean dengan shape yang sama sebagai "masker" untuk memfilter elemen. Hanya elemen di mana maskernya True yang akan dipilih. Ini adalah teknik yang sangat kuat untuk analisis data.

Python


```python
data = np.arange(10, 20) # 

# Fancy Indexing: memilih elemen di indeks 0, 3, dan 8
pilihan_fancy = data[]
print(f"Hasil Fancy Indexing: {pilihan_fancy}") # Output: [10 13 18]

# Boolean Indexing: memilih elemen yang lebih besar dari 15
mask = data > 15
pilihan_boolean = data[mask]
print(f"Hasil Boolean Indexing: {pilihan_boolean}") # Output: [16 17 18 19]
```
Ada hierarki efisiensi dalam metode pengindeksan. *Slicing* dasar yang menghasilkan *view* adalah yang tercepat karena hanya memanipulasi metadata. *Fancy* dan *Boolean indexing* lebih lambat karena mereka harus mengalokasikan memori baru dan menyalin data. Memahami perbedaan ini membantu dalam menulis kode yang lebih performan.
